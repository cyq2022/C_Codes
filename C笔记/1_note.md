# 变长数组

![image-20231001173018053](assets/image-20231001173018053.png)



# 操作符

sizeof() , 字节长度

![image-20231001174215168](assets/image-20231001174215168.png)

是用来计算变量所占内存空间的大小 





逗号表达式

![image-20231002160007383](assets/image-20231002160007383.png)



【】 下标引用操作符

![image-20231002160155320](assets/image-20231002160155320.png)

（） 函数调用操作符

![image-20231002160307334](assets/image-20231002160307334.png)





# 关键字



![image-20231002160640583](assets/image-20231002160640583.png)

extern 声明外部符号

goto 跳转

register 寄存器  static 静态

sizeof  计算字节大小

enum 枚举

struct 结构体

typedef 类型重命名

![image-20231002161101991](assets/image-20231002161101991.png)



## typedef  struct 

typedef 类型重命名

![image-20231002162214110](assets/image-20231002162214110.png)



## static 

局部变量  改变存储位置



![image-20231002162737293](assets/image-20231002162737293.png)



修饰全局变量 改变链接属性

作用域变小

![image-20231002164254915](assets/image-20231002164254915.png)

![image-20231002164351120](assets/image-20231002164351120.png)



修饰函数 同修饰全局变量

![image-20231002165144620](assets/image-20231002165144620.png)



## register

![image-20231002165709747](assets/image-20231002165709747.png)

register int num = 3;

建议存放3在寄存器



## #define 

define  定义：宏  替换作用

define  定义标识符常量

![image-20231002170350423](assets/image-20231002170350423.png)



## const

const 放在\* 左   限制指针变量指向的对象

​      放在\* 右   限制本身地址改变 

https://www.bilibili.com/video/BV1Vm4y1r7jY?t=6932.0&p=89

![image-20231005211513221](assets/image-20231005211513221.png)



const char* src  保护原数组元素不改变



![image-20231005212352831](assets/image-20231005212352831.png)



![image-20231005212658243](assets/image-20231005212658243.png)





const修饰的变量 不能直接修改

； 需要高一级指针来改

![image-20231005204757185](assets/image-20231005204757185.png)

![image-20231005205315531](assets/image-20231005205315531.png)

# 指针

## 内存

​	![image-20231002171315500](assets/image-20231002171315500.png)



一个内存单元1byte

存10 的过程

&a 取a 的地址

内存16进制表示 

打印地址 “%p”

![image-20231002172749364](assets/image-20231002172749364.png)



## 指针

存地址 -》 指针变量  int* p

指针变量是变量

![image-20231002173147970](assets/image-20231002173147970.png)





![image-20231002173356626](assets/image-20231002173356626.png)

![image-20231002173416947](assets/image-20231002173416947.png)

 int   * p 

只要吧数据存到指针变量这， 就是地址   





存地址意义 ： *p 对地址解用 ， 通过指针变量， 找到指向的对象

​		*p 就是 p 的对象

![image-20231002173840465](assets/image-20231002173840465.png)



指针变量大小 

![image-20231002174804903](assets/image-20231002174804903.png)



数组传参传递首元素地址



![image-20231002204819652](assets/image-20231002204819652.png)



# 结构体

指针变量 风格

<img src="assets/image-20231002175009906.png" alt="image-20231002175009906" style="zoom:25%;" />

int *p    

int* p



![image-20231002175817107](assets/image-20231002175817107.png)

访问结构体对象

-> :  结构体指针变量  -> 成员名

. : 结构体对象.成员名





# 分支和循环（控制语句

## if else 

![image-20231002181055434](assets/image-20231002181055434.png)

 if  else 合起来是一条语句

else 找最近的 if 



## 代码风格

![image-20231002181725260](assets/image-20231002181725260.png)

判断条件  数字在前

## swith

![image-20231002182201378](assets/image-20231002182201378.png)

风格：  每个switch末尾 default ： break； 



switch（） 括号中只能是整型表达式  char int....

不可是 浮点数



## while 

break ； 作用与循环

![image-20231002182700571](assets/image-20231002182700571.png)

执行到if 中的break 推出循环

例子

![image-20231002190512010](assets/image-20231002190512010.png)



读入 字符 

## getchar() 

函数读入字符 存为int的阿斯克吗 

​			若读入失败 ， 返回EOF （-1）

![image-20231002183746179](assets/image-20231002183746179.png)

## scanf

读到空格后停止



## 读取缓冲区

![image-20231002185452596](assets/image-20231002185452596.png)

缓冲区 ： abcdf\n

按下回车后 缓冲区可读 分两次读入缓冲区内容

用getchar() 读取\n



消除缓冲区

![image-20231002190024226](assets/image-20231002190024226.png)

读取字符 包括空格， 直到\n     把\n存到ch



## printf()函数

返回字符个数int， 若有错误返回负数



## goto语句

![image-20231002211331438](assets/image-20231002211331438.png)

一次性跳出多层循环 



关机程序  

![image-20231002211856010](assets/image-20231002211856010.png)

# 函数

## 是什么

子程序 

库函数  

自定义函数



## 函数传值传址

传值

![image-20231003104547226](assets/image-20231003104547226.png)

传参不穿地址

形参实参拥有不同的内存块

当实参传递给形参的时候，形参是实参的一份临时拷贝
对形参的修改不会影响实参



传地址

![image-20231003105041895](assets/image-20231003105041895.png)

函数用指针变量接受地址 

*p 解地址 



什么时候需要传递地址 ： 函数需要改变实参；



## 嵌套调用 

互相调用

## 链式访问

函数返回值做为其他函数的参数

![image-20231003111540662](assets/image-20231003111540662.png)

## 函数默认返回值 不推荐写法

![image-20231003111810576](assets/image-20231003111810576.png)

### 不写返回类型 默认返回int 

### 函数内没有写返回语句 ， 函数需要返回值， 默认返回最后最后一条结果

![image-20231003112008534](assets/image-20231003112008534.png)





![image-20231003112156002](assets/image-20231003112156002.png)

### 如上， 形参void  明确说明 test不需要参数



### main函数有参数

![image-20231003112411591](assets/image-20231003112411591.png)





## 函数声明定义

![image-20231003113839093](assets/image-20231003113839093.png)

![image-20231003113916641](assets/image-20231003113916641.png)

函数 ： 先声明后使用  



引用头文件相当于把函数声明拷贝

### 函数模块

函数定义在头文件中 add.h

add.h  头文件函数声明

add.c  函数定义

组合为一个模块



### 为什么这么搞

![image-20231003120927847](assets/image-20231003120927847.png)

函数定义代码编译二进制静态库 防盗版





# 递归

打印1234整数

![image-20231003133608230](assets/image-20231003133608230.png)

大事化小   

拆成123 和 4 ； 若123只有个位数 停止拆



## 递归必要条件

存在限制条件，当满足这个限制条件的时候，递归便不再继续。
每次递归调用之后越来越接近这个限制条件。 





## 模拟strlen

![image-20231003135412466](assets/image-20231003135412466.png)

地址加一是跳到下一个单元，不是单纯的内存大小

```c
#include <stdio.h>

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int *ptr = arr;

    printf("Initial value: %d\n", *ptr); // 输出第一个元素：1

    ptr++; // 指针自增

    printf("After increment: %d\n", *ptr); // 输出下一个元素：2

    return 0;
}
```



## 递归与迭代



迭代 ： 循环 非迭代



### 比较斐波那契

递归求斐波那契数列   

大量重复计算  n太大程序会崩溃栈溢出

![image-20231003143830221](assets/image-20231003143830221.png)



迭代求斐波那契数列

速度快

![image-20231003144152844](assets/image-20231003144152844.png)

新建3个变量

![image-20231003144445868](assets/image-20231003144445868.png)

### 优化递归

​	

可能使用静态对象





### 辗转相除 取模和除法

18 % 24    // 兜里有18要一次性还24 ， 换不了 还有18

24 % 18       换的了一次 ， 还剩6

  

### 走台阶题

![image-20231004201736840](assets/image-20231004201736840.png)





# 一维数组

## 定义

变长数组  （支持c99） vs不支持c99

不能初始化

int arr[n]  n是变量 



## 初始化

不完全初始化

int 初始化 0

字符 初始化 \0







```c
	int arr[10] = { 1,2,3 };  // 余下全为0

	char ch[10] = { 'a','b','c' };  // a b c 余下全为 ’\0‘

	char ch[10] = "abc";   //  a b c \0  余下全为’\0‘
```

​	



动态初始化 	

```c
	int arr[] = {1,2,3}

	char ch[] = "abc"  //  a b c \0 
```







## 迷思：

1.  

```c
 char ch[10] = {0};  
 // strlen(ch) => 0
声明了一个长度为10的字符数组ch，并将数组中的所有元素初始化为零。这样的初始化会在数组中的每个位置上放置一个空字符，因此整个数组实际上是一个空字符串
  
  若想第一位为0 ；
  char ch[10] = "0";
```



2 . 

```c
char ch[] = {'a','b','c'}; // 不包含\0
printf("%s \n",ch);
 // 打印直到 遇见\0; 
	// 遇见乱码
```

![image-20231004165105765](assets/image-20231004165105765.png)



## 一维数组

[] 下标引用操作符

计算数组大小 ：int sz =  sizeof(arr) / sizeof(arr[0]) 

![image-20231003173500163](assets/image-20231003173500163.png)

数组在内存中连续存放 





## 二维数组



int arr\[a][b]  = {1,2,3,4,5,6,7,8}

int arr\[a][b]  = {{1,2},{3,4},{5,6}}

列 不能省略

<img src="assets/image-20231003174428062.png" alt="image-20231003174428062"  />





二维数组内存 

  同样连续存储 初始化时列不能省略 

<img src="assets/image-20231003175237900.png" alt="image-20231003175237900" style="zoom:50%;" />



## 数组越界



越界打印随机值 不报错

![image-20231003175710822](assets/image-20231003175710822.png)



## 数组传参

数组作为函数参数

​	传去的是首个元素地址 ， 是指针变量

![image-20231003182357365](assets/image-20231003182357365.png)



数组传参 ： 形参可以是  int arr[]  也可以是 int \*arr 

`int *arr[]`，这意味着`arr`是一个指针数组，而不是一个指向整型数组的指针。





坑： 函数内部求数组长度

## 数组名是什么



### 一维数组数组名：

数组名表示首元素的地址

但是有2个例外表示整个数组名：：：：
1,s1zeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小，单位是字节
2,&数组名，这里的数组名表示整个数组，取出的是整个数组的地址



迷思： sizeof(数组地址 、数组指针) =》 计算地址内存大小 =》8

​		但是strlen(数组地址 、数组指针) 可以计算出数组大小

![image-20231003191109841](assets/image-20231003191109841.png)

&数组名   表示 数组地址 +1跳过整个数组

![image-20231003191232676](assets/image-20231003191232676.png)



misi



#### 二维数组数组名：

arr 

二维数组数组名 arr 表示 第一行数组的地址 



求二维数组行列

sizeof(arr) / sizeof(arr[0])  行数

&arr+1  跳过整个二维数组

![image-20231003200102041](assets/image-20231003200102041.png)

## 数组迷思

### strlen 与 数组名 

```c
char str[] = "abcdef";
char* ps = str;
printf("%d\n", strlen(str)); //6
	//printf("%d\n", strlen(s + 1));   //5
printf("%d\n", strlen(ps));   //6   strlen数组指针
printf("%d\n", sizeof(ps));// 地址8
printf("%d\n", sizeof(str));// 数组7  包含\0  
```

![image-20231004155216840](assets/image-20231004155216840.png)





### 数组类型 

int arr[10] = {0};   数组类型 是 int [10]



![image-20231004113835254](assets/image-20231004113835254.png)



### 迷思数组拷贝

char name[20] = {0};
name = "abc";
为什么不对

数组名不能被重新赋值。

在C语言中，数组名是一个常量指针，它指向数组的第一个元素。在你的代码中，`name`是一个字符数组，它被声明为`char name[20]`，并且初始化为全零。但是，数组名不能被重新赋值。

当你尝试将字符串字面量`"abc"`赋值给`name`时，这是不允许的，因为数组名不能被赋值。你可以使用字符串函数如`strcpy`来将字符串拷贝到数组中，或者可以逐个字符地赋值给数组的元素。

# 操作符

![image-20231004135924585](assets/image-20231004135924585.png)

## 算数操作符



### 算数操作符

/ 除号   得商   

% 取模号  得余     %两端必须为整数

## 移位操作符 （整数

![image-20231004143104746](assets/image-20231004143104746.png)

#### 左移

移动 整数 二进制位 补码 



<< 左移操作符  \*2 



#### 右移



算数右移 高位补原  基本上编译器用算数右移	

逻辑右移 高位补0

![image-20231004142201063](assets/image-20231004142201063.png)





![image-20231004142333709](assets/image-20231004142333709.png)





位移＋赋值

a >>= 1



## 位操作符  （整数





& 按位与   ： 全1为1 ， 

![image-20231004143244102](assets/image-20231004143244102.png)



|  按位或  ： 有1为1 ； 



^  按位异或 ；  不同为1 ； 相同为0 





异或实现两个数的交换  （ 只适用于整型 ， 可读性差， 速度低）

```c
 a ^ a = 0;
 a ^ 0 = a;

 a ^ b ^ a = b;
```

![image-20231004144242443](assets/image-20231004144242443.png)





## 赋值操作符



![image-20231004150119253](assets/image-20231004150119253.png)





## 单目操作符

![image-20231004150258046](assets/image-20231004150258046.png)

只有1个操作数  ！a

双目 a + b 有两个





###  取地址& 

取变量在内存中的起始地址

int a = 10 ;

&a  取的是 a 4个字节中第一个字节的地址





### sizeof()

传入数组地址 ， 计算整个数组大小

![image-20231004151502428](assets/image-20231004151502428.png)



sizeof 是操作符不是函数



![image-20231004154351046](assets/image-20231004154351046.png)

### \~

二进制整数补码按位取反

![image-20231004153352095](assets/image-20231004153352095.png)

按位与  都才行 我条件都给你 我都1除了不想让你1 的地方我给0

按位或  有就行 我其他都是0 你要什么我哪里写1 



### ++ --



### \* 间接访问操作符（解引用操作符）





### 比较运算符



== ：

“abc” == “abcdef”  : 比较连字符串首字母地址

​	

== 比较浮点数 需要考虑精度





### 逻辑运算符

&& 

||

返回值 : 真1假0





### []操作符号

![image-20231004161432431](assets/image-20231004161432431.png)

都可以写如上



### （）函数调用操作符

![image-20231004161620693](assets/image-20231004161620693.png)





### 结构体

![image-20231004162830390](assets/image-20231004162830390.png)



传结构体参数  ， 要修改原先对象时， 要传地址



访问结构体成员 ： 结构体成员地址p 

1.   p -> age
2.   \*p . age  



### 表达式求值



表达式求值的顺序一部分是由操作符的优先级和结合性决定。

优先级  

结合性  



### 隐式类型转换 整型提升

有些表达式的操作数在求值的过程中可能需要转换为其他类型。

C的整型算术运算总是至少以默认整型类型的精度来进行的。

为了获得这个精度，表达式中的**字符和短整型操作数**在使用之前被转换为普通整型，这种转换称为整型提升。I



#### 整型提升意义：

![image-20231004184302360](assets/image-20231004184302360.png)





#### 整位提升 方法

负数高位补1 

正数高位补0

算完再截断

![image-20231004185244037](assets/image-20231004185244037.png)



eg:

1

```c
int main()
{
	char c = 387;       
	//  先整型提升后截断 最后存储
	//  00000000 00000000 00000001 1000 0011
	printf("%d \n", c); // -125    1000 0011
	return 0;
}
```

2 

```c
int main()
{
  char a = 0xb6;   // 1011 0110
  // 计算时高位补1
  if (a == 0xb6) printf("a"); 
}
```

3

整型提升后按 整型计算大小

![3](assets/image-20231004194319153.png)







#### 算数转换

转换成相同类型 进行操作

![image-20231004194647764](assets/image-20231004194647764.png)



### 迷思

```c
int i = 0;
i--;
i > sizeof(i)  // int  -1 >  unsign int 4
  
  发生类型转换  -1 =>  高位1 不表示符号
```



![image-20231005162949288](assets/image-20231005162949288.png)



## 操作符优先级结合性

![image-20231004194940709](assets/image-20231004194940709.png)

http://c.biancheng.net/view/285.html



优先级： 相邻操作符不同    2 + 3  *  4  + 2  先算*

结合性： 先算哪个 + 



迷思： 

我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题

### 问题表达式

  不说人话

​	不确定计算路径 。 结果可能不唯一

![image-20231004200108198](assets/image-20231004200108198.png)

![image-20231004200218142](assets/image-20231004200218142.png)

![image-20231004200355788](assets/image-20231004200355788.png)









# 指针

D:\桌面\C_Codes\C笔记\2_指针笔记.md



# 结构体

![image-20231005151842203](assets/image-20231005151842203.png)



## 声明

![image-20231005152429611](assets/image-20231005152429611.png)

```c
 struct 结构体名
 {
   成员列表
 }变量列表 ；
```

结构体变量创建在main外 属于全局变量



可创建在main内



## 初始化

```c
struct Point 
{
	int x;
  int y;
}	p1; 

struct Point p2;
```





## 访问

p1 -> x; 

p1.x;



## 传参

传指针

![image-20231005153909397](assets/image-20231005153909397.png)



传 结构体变量  拷贝结构体 性能低

传 结构体指针	首选



# 迷思

![image-20231005162553427](assets/image-20231005162553427.png)







# 调试

## bebug  release

![image-20231005165103984](assets/image-20231005165103984.png)

![image-20231005165343411](assets/image-20231005165343411.png)

## 调试

### 内存

​	两个二位十六进制数字 代表一个最小内存单元 1个字节

### 监视：临时变量

### 调用堆栈

### 寄存器

## 快捷键

F5 开始调试 / 跳到下一个断点

F9 断点 

F10 按过程

F11 

https://blog.51cto.com/itcjf/3015490



## 迷思

1

传过去的数组名   

a，10  可访问余下： 

![image-20231005185807385](assets/image-20231005185807385.png)

 

2

取决于编译器

![image-20231005201420831](assets/image-20231005201420831.png)

局部变量储存在栈区



数组随着下标增长 ， 地址由低到高





## 如何写好代码



assert

const
