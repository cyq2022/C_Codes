# 

![image-20231006165413989](assets/image-20231006165413989.png)

# 数据类型



整型家族

![image-20231006165822625](assets/image-20231006165822625.png)

char 本质是整型





char 比较特殊

char到底是signed char还是unsigned char标准是未定义的，

取决于编译器的实现。



**整型**

**浮点型**

**构造类型**

**指针类型**

**空类型**

![image-20231006170620597](assets/image-20231006170620597.png)



# 整型在内存存储

内存存放整型补码 二进制序列



cpu只有加法器

![image-20231006181441449](assets/image-20231006181441449.png)

使用补码 ： 将符号位和值阈 统一处理

 1 + (-1) 



原码 取反 + 1 =》 补码

补码 取反 + 1 =》 原码 // 补码的补码是原码 = 》 运算过程相同



# 大小端

![image-20231006183030640](assets/image-20231006183030640.png)



大端字节序  高位先存



![image-20231006183624947](assets/image-20231006183624947.png)



# 数据的范围

## 有符号char

![image-20231006184945864](assets/image-20231006184945864.png)

1000 0000  直接解析成 最小值-128 ， 不进行按位取反+1求原码



范围-128 ~ 127



## 无符号char

![image-20231006185135821](assets/image-20231006185135821.png)



short

![image-20231006185335429](assets/image-20231006185335429.png)







# 整型提升 截断

按照补码



![image-20231006191226149](assets/image-20231006191226149.png)

## char a = -1;

把-1 赋给 char 

-1 换成二进制表示1000000000000000000000000001

-1 在内存中      1111111111111111111111111111

把在内存中的数据给char

 char 内存 11111111

​	原码 ： 10000001  = -1

## unsigned char c = -1;

把-1 赋给 char 

-1 换成二进制表示1000000000000000000000000001

-1 在内存中      1111111111111111111111111111

把在内存中的数据给char

 char 内存 11111111

​	原码： 无符号数值高位补0 

​		 00000000000000000011111111 = 255 



%d 打印的是有符号整型 // 打印char会整型提升





## char a = -128; 

![image-20231006201826293](assets/image-20231006201826293.png)

char a = -128;

10000000 00000000 00000000 100000000   // -128 原码

11111111 11111111 11111111 100000000   // -128 补码

截断 =》 				   100000000 内存存储；

printf(“%u”, a);

11111111111111111111111111 10000000  // -128 整型提升（补码）

%u 打印 补码 11111111111111111111111110000000  =》	

​				4,294,967,168

%d 打印 有符号整型（原码） 

​	 10000000 00000000 00000000 100000000  // -128；





![image-20231006202431050](assets/image-20231006202431050.png)

